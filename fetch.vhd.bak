USE work.my_pkg.ALL;
USE work.my_pkg1.ALL;

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;
ENTITY fetch IS
    PORT (
        clk : IN STD_LOGIC;
        registers : IN register_array(0 TO 7)(31 DOWNTO 0);
        jz : IN STD_LOGIC;
        jz_address : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
        instruction : OUT STD_LOGIC_VECTOR (31 DOWNTO 0);
        next_pc : OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
    );
END ENTITY;
ARCHITECTURE arch_fetch OF fetch IS

    COMPONENT instruction_memory
        PORT (
            clk : IN STD_LOGIC;
            address : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
            dataout1 : OUT STD_LOGIC_VECTOR(15 DOWNTO 0);
            dataout2 : OUT STD_LOGIC_VECTOR(15 DOWNTO 0)

        );
    END COMPONENT;
    SIGNAL one : STD_LOGIC_VECTOR(31 DOWNTO 0) := (0 => '1', OTHERS => '0');
    SIGNAL two : STD_LOGIC_VECTOR(31 DOWNTO 0) := (1 => '1', OTHERS => '0');
    SIGNAL pc : STD_LOGIC_VECTOR(31 DOWNTO 0) := (OTHERS => '0');
BEGIN
    instruction <= (OTHERS => 'Z');

    memory_instance_1 : instruction_memory PORT MAP(clk, pc(11 DOWNTO 0), (OTHERS => '0'), instruction(31 DOWNTO 16), instruction(15 DOWNTO 0));

    fetch_unit : PROCESS (instruction) IS
    BEGIN

        --jump or call
        IF instruction(31 DOWNTO 23) = "100100000" OR instruction(31 DOWNTO 23) = "100110000" THEN
            next_pc <= registers(to_integer(unsigned(instruction(22 DOWNTO 20))));

            --jz
        ELSIF jz = '1' THEN
            next_pc <= jz_address;
            --ret or rti  ---save 3 location with nop
        ELSIF instruction(31 DOWNTO 23) = "101000000" OR instruction(31 DOWNTO 23) = "101010000" THEN
            next_pc <= (OTHERS => '0');

        ELSE
            next_pc <= pc + two;

            -- END IF;
        END IF;
    END PROCESS;

END ARCHITECTURE;